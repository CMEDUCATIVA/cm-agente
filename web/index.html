<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CM-Agente Realtime</title>
  <style>
    :root {
      --bg: #f6f2ed;
      --panel: #ffffff;
      --ink: #1c1c1c;
      --muted: #6b6b6b;
      --accent: #e04f2a;
      --accent-2: #2b7a78;
      --ring: rgba(224, 79, 42, 0.25);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, #fbe9df, transparent),
                  radial-gradient(1000px 500px at 120% 10%, #d6f0ee, transparent),
                  var(--bg);
      color: var(--ink);
    }
    .wrap {
      max-width: 860px;
      margin: 48px auto;
      padding: 0 20px;
    }
    .card {
      background: var(--panel);
      border-radius: 18px;
      padding: 28px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
    }
    h1 {
      font-size: 28px;
      margin: 0 0 8px;
      letter-spacing: -0.3px;
    }
    .sub {
      color: var(--muted);
      margin: 0 0 24px;
    }
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 18px;
    }
    button {
      appearance: none;
      border: 0;
      background: var(--accent);
      color: #fff;
      padding: 12px 18px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.2s ease;
      box-shadow: 0 6px 18px var(--ring);
    }
    button.secondary { background: #111; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    button:active { transform: translateY(1px); }
    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      background: #f2f2f2;
      color: var(--muted);
      font-size: 13px;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #bbb;
    }
    .dot.live { background: var(--accent); box-shadow: 0 0 0 6px var(--ring); }
    .panel {
      background: #fafafa;
      border: 1px dashed #e0e0e0;
      border-radius: 12px;
      padding: 12px;
      font-size: 14px;
    }
    .label { font-weight: 600; margin-bottom: 6px; }
    audio { width: 100%; margin-top: 8px; }
    .hint { font-size: 12px; color: var(--muted); }
    #log {
      max-height: 220px;
      overflow-y: scroll;
      white-space: pre-wrap;
      font-family: "IBM Plex Mono", "SFMono-Regular", monospace;
      background: #f7f3ef;
      border-radius: 8px;
      padding: 8px;
      user-select: text;
    }
    .panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }
    .panel-head .label {
      margin-bottom: 0;
    }
    #copyLogBtn {
      background: #111;
      color: #fff;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Conversacion Realtime</h1>
      <p class="sub">WebRTC full-duplex con barge-in basico. Abre microfono y puedes interrumpir.</p>

      <div class="controls">
        <button id="connectBtn">Conectar</button>
        <button id="talkBtn" class="secondary" disabled>Hablar (mute)</button>
        <button id="interruptBtn" disabled>Interrumpir</button>
        <span class="status"><span id="dot" class="dot"></span><span id="statusText">Desconectado</span></span>
      </div>

      <div class="panel">
        <div class="panel-head">
          <div class="label">Estado</div>
          <button id="copyLogBtn">Copiar log</button>
        </div>
        <div id="log">—</div>
        <div class="hint">Requiere HTTPS o localhost para el microfono.</div>
      </div>

      <div class="panel">
        <div class="label">Transcripcion</div>
        <div id="transcript">—</div>
      </div>

      <div class="panel">
        <div class="label">Respuesta</div>
        <div id="reply">—</div>
        <audio id="remoteAudio" controls></audio>
      </div>

      <div class="panel">
        <div class="label">Instrucciones (estilo de habla)</div>
        <div class="hint">Se aplican al crear la sesiÃ³n. Cambia y reconecta.</div>
        <div style="display:grid;gap:8px;margin-top:8px;">
          <textarea id="seqStep1" placeholder="Secuencia Paso 1: ..."></textarea>
          <textarea id="seqStep2" placeholder="Secuencia Paso 2: ..."></textarea>
          <textarea id="seqStep3" placeholder="Secuencia Paso 3: ..."></textarea>
          <textarea id="seqStep4" placeholder="Secuencia Paso 4 (opcional): ..."></textarea>
          <textarea id="seqStep5" placeholder="Secuencia Paso 5 (opcional): ..."></textarea>
          <textarea id="instBase" placeholder="Base: rol, idioma, tono general"></textarea>
          <textarea id="instStyle" placeholder="Estilo: longitud, ritmo, tecnicismos, formato"></textarea>
          <textarea id="instRules" placeholder="Reglas: lo que nunca debe hacer"></textarea>
          <textarea id="instSpecial" placeholder="EspecializaciÃ³n: contexto de negocio/producto"></textarea>
          <textarea id="instExtra" placeholder="Extra: saludo fijo, cierre fijo, palabras prohibidas"></textarea>
        </div>
      </div>

    </div>
  </div>

  <script>
    const connectBtn = document.getElementById('connectBtn');
    const talkBtn = document.getElementById('talkBtn');
    const interruptBtn = document.getElementById('interruptBtn');
    const statusText = document.getElementById('statusText');
    const dot = document.getElementById('dot');
    const logEl = document.getElementById('log');
    const copyLogBtn = document.getElementById('copyLogBtn');
    const transcriptEl = document.getElementById('transcript');
    const remoteAudio = document.getElementById('remoteAudio');
    const replyEl = document.getElementById('reply');
    const seqStep1 = document.getElementById('seqStep1');
    const seqStep2 = document.getElementById('seqStep2');
    const seqStep3 = document.getElementById('seqStep3');
    const seqStep4 = document.getElementById('seqStep4');
    const seqStep5 = document.getElementById('seqStep5');
    const instBase = document.getElementById('instBase');
    const instStyle = document.getElementById('instStyle');
    const instRules = document.getElementById('instRules');
    const instSpecial = document.getElementById('instSpecial');
    const instExtra = document.getElementById('instExtra');
    const STORAGE_KEY = 'cm_realtime_instructions_v1';

    let pc;
    let dc;
    let localStream;
    let micTrack;
    let ws;

    let audioQueue = [];
    let mediaSource;
    let sourceBuffer;
    let endOfStreamPending = false;
    let audioBufferedBytes = 0;
    let playbackStarted = false;
    const MIN_PLAY_BYTES = 10000;
    const MIN_APPEND_BYTES = 6000;

    function setStatus(text, live=false) {
      statusText.textContent = text;
      dot.classList.toggle('live', live);
      log(`status: ${text}`);
    }

    const logLines = [];
    const LOG_MAX_LINES = 100;
    function log(msg) {
      logLines.push(msg);
      if (logLines.length > LOG_MAX_LINES) {
        logLines.splice(0, logLines.length - LOG_MAX_LINES);
      }
      logEl.textContent = logLines.join('\n');
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function copyLog() {
      const text = logLines.join('\n');
      if (!text.trim()) return;
      try {
        await navigator.clipboard.writeText(text);
        log('log: copiado');
      } catch (err) {
        log('log: no se pudo copiar');
      }
    }

    function resetAudioStream() {
      audioQueue = [];
      endOfStreamPending = false;
      audioBufferedBytes = 0;
      playbackStarted = false;
      mediaSource = new MediaSource();
      remoteAudio.src = URL.createObjectURL(mediaSource);
      mediaSource.addEventListener('sourceopen', () => {
        sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg');
        sourceBuffer.addEventListener('updateend', appendNextChunk);
        appendNextChunk();
      }, { once: true });
    }

    function appendNextChunk() {
      if (!sourceBuffer || sourceBuffer.updating) return;
      if (audioQueue.length > 0) {
        let total = 0;
        let parts = [];
        while (audioQueue.length > 0 && total < MIN_APPEND_BYTES) {
          const part = audioQueue.shift();
          parts.push(part);
          total += part.length;
        }
        if (parts.length === 1) {
          sourceBuffer.appendBuffer(parts[0]);
        } else {
          const merged = new Uint8Array(total);
          let offset = 0;
          for (const part of parts) {
            merged.set(part, offset);
            offset += part.length;
          }
          sourceBuffer.appendBuffer(merged);
        }
      } else if (endOfStreamPending && mediaSource.readyState === 'open') {
        mediaSource.endOfStream();
      }
    }

    function pushAudioChunk(b64) {
      const binary = atob(b64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      audioQueue.push(bytes);
      audioBufferedBytes += bytes.length;
      appendNextChunk();
      if (!playbackStarted && audioBufferedBytes >= MIN_PLAY_BYTES) {
        playbackStarted = true;
        remoteAudio.play().catch(() => {});
      }
    }

    function connectWs() {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        return;
      }
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      ws = new WebSocket(`${proto}://${location.host}/voice/ws`);
      ws.onopen = () => {
        log('ws: abierto');
        ws.send(JSON.stringify({ type: 'config' }));
        log('ws: enviado config');
      };
      ws.onclose = () => log('ws: cerrado');
      ws.onerror = () => log('ws: error');
      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          log(`ws: ${msg.type}`);
          if (msg.type === 'text_delta') {
            if (replyEl) replyEl.textContent += msg.text || '';
          } else if (msg.type === 'final_text') {
            if (replyEl) replyEl.textContent = msg.text || replyEl.textContent;
          } else if (msg.type === 'audio_chunk') {
            if (!mediaSource) resetAudioStream();
            pushAudioChunk(msg.data);
            log(`ws: audio_chunk (${msg.data ? msg.data.length : 0})`);
          } else if (msg.type === 'audio_end') {
            endOfStreamPending = true;
            appendNextChunk();
            if (!playbackStarted) {
              playbackStarted = true;
              remoteAudio.play().catch(() => {});
            }
            log('ws: audio_end');
          } else if (msg.type === 'error') {
            log(`LLM/TTS error: ${msg.message || 'error'}`);
          }
        } catch {}
      };
    }

    function loadInstructions() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (data.seq1 && seqStep1) seqStep1.value = data.seq1;
        if (data.seq2 && seqStep2) seqStep2.value = data.seq2;
        if (data.seq3 && seqStep3) seqStep3.value = data.seq3;
        if (data.seq4 && seqStep4) seqStep4.value = data.seq4;
        if (data.seq5 && seqStep5) seqStep5.value = data.seq5;
        if (data.base && instBase) instBase.value = data.base;
        if (data.style && instStyle) instStyle.value = data.style;
        if (data.rules && instRules) instRules.value = data.rules;
        if (data.special && instSpecial) instSpecial.value = data.special;
        if (data.extra && instExtra) instExtra.value = data.extra;
        log('Instrucciones cargadas desde el navegador');
      } catch {
        // ignore
      }
    }

    function saveInstructions() {
      try {
        const data = {
          seq1: seqStep1 ? seqStep1.value : '',
          seq2: seqStep2 ? seqStep2.value : '',
          seq3: seqStep3 ? seqStep3.value : '',
          seq4: seqStep4 ? seqStep4.value : '',
          seq5: seqStep5 ? seqStep5.value : '',
          base: instBase ? instBase.value : '',
          style: instStyle ? instStyle.value : '',
          rules: instRules ? instRules.value : '',
          special: instSpecial ? instSpecial.value : '',
          extra: instExtra ? instExtra.value : '',
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch {
        // ignore
      }
    }

    function buildInstructions() {
      const parts = [];
      const push = (label, value) => {
        const v = (value || '').trim();
        if (v) parts.push(`${label}:\n${v}`);
      };
      const seqParts = [];
      if (seqStep1 && seqStep1.value.trim()) seqParts.push(`1) ${seqStep1.value.trim()}`);
      if (seqStep2 && seqStep2.value.trim()) seqParts.push(`2) ${seqStep2.value.trim()}`);
      if (seqStep3 && seqStep3.value.trim()) seqParts.push(`3) ${seqStep3.value.trim()}`);
      if (seqStep4 && seqStep4.value.trim()) seqParts.push(`4) ${seqStep4.value.trim()}`);
      if (seqStep5 && seqStep5.value.trim()) seqParts.push(`5) ${seqStep5.value.trim()}`);
      if (seqParts.length) {
        push('Secuencia obligatoria', seqParts.join('\n'));
      }
      push('Base', instBase && instBase.value);
      push('Estilo', instStyle && instStyle.value);
      push('Reglas', instRules && instRules.value);
      push('EspecializaciÃ³n', instSpecial && instSpecial.value);
      push('Extra', instExtra && instExtra.value);
      return parts.join('\n\n');
    }

    async function connect() {
      connectBtn.disabled = true;
      setStatus('Conectando...', true);
      log('webrtc: iniciando');
      try {
        connectWs();
        pc = new RTCPeerConnection();
        pc.onicegatheringstatechange = () => {
          log(`webrtc: ICE ${pc.iceGatheringState}`);
        };
        pc.onconnectionstatechange = () => {
          log(`webrtc: RTC ${pc.connectionState}`);
        };
        dc = pc.createDataChannel('oai-events');
        dc.onopen = () => log('realtime: datachannel abierto');
        dc.onmessage = (e) => {
          try {
            const evt = JSON.parse(e.data);
            if (evt.type === 'response.audio.delta') {
              // Audio llega por la pista remota, solo log ligero
            } else if (evt.type === 'conversation.item.input_audio_transcription.completed') {
              const text = evt.transcript || '';
              if (text && transcriptEl) transcriptEl.textContent = text;
              log(`realtime: transcripcion (${text.length} chars)`);
              if (text && ws && ws.readyState === WebSocket.OPEN) {
                if (replyEl) replyEl.textContent = '';
                resetAudioStream();
                ws.send(JSON.stringify({ type: 'text', text }));
                log('ws: enviado texto al LLM');
              }
            } else if (evt.type) {
              log(`realtime: ${evt.type}`);
            }
          } catch {}
        };

        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (err) {
          log(`Error mic: ${err && err.message ? err.message : err}`);
          setStatus('Error mic', false);
          connectBtn.disabled = false;
          return;
        }
        micTrack = localStream.getAudioTracks()[0];
        micTrack.enabled = false; // push-to-talk inicial
        pc.addTrack(micTrack, localStream);

        // Realtime audio no se usa en este flujo
        pc.ontrack = () => {};

        log('webrtc: creando offer');
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        log('webrtc: offer listo');

        // Wait for ICE gathering to complete so SDP has candidates (with timeout)
        await Promise.race([
          new Promise((resolve) => {
            if (pc.iceGatheringState === 'complete') return resolve();
            pc.addEventListener(
              'icegatheringstatechange',
              () => {
                if (pc.iceGatheringState === 'complete') resolve();
              },
              { once: true }
            );
          }),
          new Promise((resolve) => setTimeout(resolve, 2000)),
        ]);
        log(`webrtc: ICE final ${pc.iceGatheringState}`);

        const sdp = pc.localDescription && pc.localDescription.sdp ? pc.localDescription.sdp : '';
        log(`webrtc: SDP length ${sdp.length}`);
        if (!sdp) {
          log('webrtc: SDP vacio');
          setStatus('Error', false);
          connectBtn.disabled = false;
          return;
        }

        const instructions = buildInstructions();
        log(`realtime: instrucciones ${instructions ? 'si' : 'no'}`);
        log('realtime: enviando /realtime/session');
        let res;
        try {
          const url = '/realtime/session';
          log(`realtime: url ${url}`);
          const headers = { 'content-type': 'application/sdp' };
          if (instructions) {
            const maxLen = 4000;
            const payload = instructions.length > maxLen
              ? instructions.slice(0, maxLen)
              : instructions;
            const encoded = btoa(unescape(encodeURIComponent(payload)));
            headers['x-realtime-instructions-b64'] = encoded;
            if (instructions.length > maxLen) {
              log(`realtime: instrucciones truncadas ${maxLen}`);
            }
          }
          res = await fetch(url, {
            method: 'POST',
            headers,
            body: sdp
          });
          log(`realtime: respuesta ${res.status}`);
        } catch (err) {
          log(`realtime: error fetch ${err && err.message ? err.message : err}`);
          setStatus('Error', false);
          connectBtn.disabled = false;
          return;
        }

        if (!res.ok) {
          const msg = await res.text();
          log(`realtime: error ${msg}`);
          setStatus('Error', false);
          connectBtn.disabled = false;
          return;
        }

        const answerSdp = await res.text();
        log(`webrtc: answer SDP length ${answerSdp.length}`);
        await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

        setStatus('Conectado', true);
        talkBtn.disabled = false;
        interruptBtn.disabled = false;
      } catch (err) {
        log(`Error inesperado: ${err && err.message ? err.message : err}`);
        setStatus('Error', false);
        connectBtn.disabled = false;
      }
    }

    function toggleTalk() {
      if (!micTrack) return;
      micTrack.enabled = !micTrack.enabled;
      talkBtn.textContent = micTrack.enabled ? 'Hablar (on)' : 'Hablar (mute)';
      if (micTrack.enabled) {
        // Si el usuario empieza a hablar, cancelamos la respuesta actual
        sendEvent({ type: 'response.cancel' });
        log('realtime: respuesta cancelada');
      }
    }

    function sendEvent(payload) {
      if (dc && dc.readyState === 'open') {
        dc.send(JSON.stringify(payload));
      }
    }

    const bindSave = (el) => {
      if (!el) return;
      el.addEventListener('input', saveInstructions);
      el.addEventListener('change', saveInstructions);
    };

    connectBtn.addEventListener('click', connect);
    talkBtn.addEventListener('click', toggleTalk);
    interruptBtn.addEventListener('click', () => sendEvent({ type: 'response.cancel' }));

    bindSave(seqStep1);
    bindSave(seqStep2);
    bindSave(seqStep3);
    bindSave(seqStep4);
    bindSave(seqStep5);
    bindSave(instBase);
    bindSave(instStyle);
    bindSave(instRules);
    bindSave(instSpecial);
    bindSave(instExtra);
    copyLogBtn.addEventListener('click', copyLog);
    loadInstructions();
    log('log listo');
  </script>
</body>
</html>
